// Generated by using torchexport::export() -> do not edit by hand
#include "ignite/ignite.h"
#include <lantern/types.h>
#include "ignite/ignite_types.h"
void * p_ignite_last_error = NULL;

IGNITE_API void* ignite_last_error()
{
  return p_ignite_last_error;
}

IGNITE_API void ignite_last_error_clear()
{
  p_ignite_last_error = NULL;
}

adamw_param_groups ignite_adamw_get_param_groups (optim_adamw groups);
IGNITE_API void* _ignite_adamw_get_param_groups (void* groups) {
  try {
    return  make_raw::AdamWParamGroups(ignite_adamw_get_param_groups(from_raw::AdamW(groups)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
int ignite_adamw_param_groups_size (optim_param_groups groups);
IGNITE_API int _ignite_adamw_param_groups_size (void* groups) {
  try {
    return  (ignite_adamw_param_groups_size(from_raw::OptimParamGroups(groups)));
  } IGNITE_HANDLE_EXCEPTION
  return 10;
}
std::vector<torch::Tensor> ignite_optim_get_param_group_params (optim_param_groups groups, int i);
IGNITE_API void* _ignite_optim_get_param_group_params (void* groups, int i) {
  try {
    return  make_raw::TensorList(ignite_optim_get_param_group_params(from_raw::OptimParamGroups(groups), i));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
adamw_options ignite_adamw_get_param_group_options (optim_param_groups groups, int i);
IGNITE_API adamw_options _ignite_adamw_get_param_group_options (void* groups, int i) {
  try {
    return  make_raw::AdamWOptions(ignite_adamw_get_param_group_options(from_raw::OptimParamGroups(groups), i));
  } IGNITE_HANDLE_EXCEPTION
  return NULL;
}
void ignite_adamw_set_param_group_options (optim_adamw opt, int i, adamw_options options);
IGNITE_API void _ignite_adamw_set_param_group_options (void* opt, int i, adamw_options options) {
  try {
     (ignite_adamw_set_param_group_options(from_raw::AdamW(opt), i, from_raw::AdamWOptions(options)));
  } IGNITE_HANDLE_EXCEPTION
  
}
std::vector<torch::Tensor> ignite_adamw_get_states (optim_adamw opt);
IGNITE_API void* _ignite_adamw_get_states (void* opt) {
  try {
    return  make_raw::TensorList(ignite_adamw_get_states(from_raw::AdamW(opt)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
void ignite_adamw_set_states (optim_adamw opt, torch::TensorList states);
IGNITE_API void _ignite_adamw_set_states (void* opt, void* states) {
  try {
     (ignite_adamw_set_states(from_raw::AdamW(opt), from_raw::TensorList(states)));
  } IGNITE_HANDLE_EXCEPTION
  
}
std::vector<torch::Tensor> ignite_opt_step (script_module network, script_module loss_fn, torch_stack input, torch::Tensor target, optim_adamw optimizer);
IGNITE_API void* _ignite_opt_step (void* network, void* loss_fn, void* input, void* target, void* optimizer) {
  try {
    return  make_raw::TensorList(ignite_opt_step(from_raw::ScriptModule(network), from_raw::ScriptModule(loss_fn), from_raw::TorchStack(input), from_raw::Tensor(target), from_raw::AdamW(optimizer)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor ignite_predict_step (script_module network, torch_stack input);
IGNITE_API void* _ignite_predict_step (void* network, void* input) {
  try {
    return  make_raw::Tensor(ignite_predict_step(from_raw::ScriptModule(network), from_raw::TorchStack(input)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
optim_adamw ignite_adamw (torch::TensorList params, double lr, double beta1, double beta2, double eps, double weight_decay, bool amsgrad);
IGNITE_API void* _ignite_adamw (void* params, double lr, double beta1, double beta2, double eps, double weight_decay, bool amsgrad) {
  try {
    return  make_raw::AdamW(ignite_adamw(from_raw::TensorList(params), lr, beta1, beta2, eps, weight_decay, amsgrad));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
void ignite_adamw_step (optim_adamw opt);
IGNITE_API void _ignite_adamw_step (void* opt) {
  try {
     (ignite_adamw_step(from_raw::AdamW(opt)));
  } IGNITE_HANDLE_EXCEPTION
  
}
void ignite_adamw_zero_grad (optim_adamw opt);
IGNITE_API void _ignite_adamw_zero_grad (void* opt) {
  try {
     (ignite_adamw_zero_grad(from_raw::AdamW(opt)));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim (void* x);
IGNITE_API void _delete_optim (void* x) {
  try {
     (delete_optim(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_sgd (void* x);
IGNITE_API void _delete_optim_sgd (void* x) {
  try {
     (delete_optim_sgd(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_adam (void* x);
IGNITE_API void _delete_optim_adam (void* x) {
  try {
     (delete_optim_adam(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_adamw (void* x);
IGNITE_API void _delete_optim_adamw (void* x) {
  try {
     (delete_optim_adamw(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_adagrad (void* x);
IGNITE_API void _delete_optim_adagrad (void* x) {
  try {
     (delete_optim_adagrad(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_rmsprop (void* x);
IGNITE_API void _delete_optim_rmsprop (void* x) {
  try {
     (delete_optim_rmsprop(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_param_groups (void* x);
IGNITE_API void _delete_optim_param_groups (void* x) {
  try {
     (delete_optim_param_groups(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_param_group (void* x);
IGNITE_API void _delete_optim_param_group (void* x) {
  try {
     (delete_optim_param_group(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_adamw_param_group (void* x);
IGNITE_API void _delete_adamw_param_group (void* x) {
  try {
     (delete_adamw_param_group(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_adamw_state (void* x);
IGNITE_API void _delete_adamw_state (void* x) {
  try {
     (delete_adamw_state(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_adamw_options (void* x);
IGNITE_API void _delete_adamw_options (void* x) {
  try {
     (delete_adamw_options(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
