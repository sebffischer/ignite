// Generated by using torchexport::export() -> do not edit by hand
#include "ignite/ignite.h"
#include <lantern/types.h>
#include "ignite/ignite_types.h"
void * p_ignite_last_error = NULL;

IGNITE_API void* ignite_last_error()
{
  return p_ignite_last_error;
}

IGNITE_API void ignite_last_error_clear()
{
  p_ignite_last_error = NULL;
}

adamw_param_groups ignite_adamw_get_param_groups (optim_adamw groups);
IGNITE_API void* _ignite_adamw_get_param_groups (void* groups) {
  try {
    return  make_raw::AdamWParamGroups(ignite_adamw_get_param_groups(from_raw::AdamW(groups)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
std::vector<torch::Tensor> ignite_optim_get_param_group_params (optim_param_group group);
IGNITE_API void* _ignite_optim_get_param_group_params (void* group) {
  try {
    return  make_raw::TensorList(ignite_optim_get_param_group_params(from_raw::OptimParamGroup(group)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
double ignite_optim_get_param_group_lr (optim_param_group group);
IGNITE_API double _ignite_optim_get_param_group_lr (void* group) {
  try {
    return  (ignite_optim_get_param_group_lr(from_raw::OptimParamGroup(group)));
  } IGNITE_HANDLE_EXCEPTION
  return NULL;
}
adamw_states ignite_adamw_get_states (optim_adamw opt);
IGNITE_API void* _ignite_adamw_get_states (void* opt) {
  try {
    return  make_raw::AdamWStates(ignite_adamw_get_states(from_raw::AdamW(opt)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor adamw_state_exp_avg (adamw_state state);
IGNITE_API void* _adamw_state_exp_avg (void* state) {
  try {
    return  make_raw::Tensor(adamw_state_exp_avg(from_raw::AdamWState(state)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor adamw_state_exp_avg_sq (adamw_state state);
IGNITE_API void* _adamw_state_exp_avg_sq (void* state) {
  try {
    return  make_raw::Tensor(adamw_state_exp_avg_sq(from_raw::AdamWState(state)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor adamw_state_max_exp_avg_sq (adamw_state state);
IGNITE_API void* _adamw_state_max_exp_avg_sq (void* state) {
  try {
    return  make_raw::Tensor(adamw_state_max_exp_avg_sq(from_raw::AdamWState(state)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor adamw_state_step (adamw_state state);
IGNITE_API void* _adamw_state_step (void* state) {
  try {
    return  make_raw::Tensor(adamw_state_step(from_raw::AdamWState(state)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
std::vector<torch::Tensor> ignite_opt_step (script_module network, script_module loss_fn, torch_stack input, torch::Tensor target, optim optimizer);
IGNITE_API void* _ignite_opt_step (void* network, void* loss_fn, void* input, void* target, void* optimizer) {
  try {
    return  make_raw::TensorList(ignite_opt_step(from_raw::ScriptModule(network), from_raw::ScriptModule(loss_fn), from_raw::TorchStack(input), from_raw::Tensor(target), from_raw::Optim(optimizer)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor ignite_predict_step (script_module network, torch_stack input);
IGNITE_API void* _ignite_predict_step (void* network, void* input) {
  try {
    return  make_raw::Tensor(ignite_predict_step(from_raw::ScriptModule(network), from_raw::TorchStack(input)));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
optim_adamw ignite_adamw (torch::TensorList params, double lr, double beta1, double beta2, double eps, double weight_decay, bool amsgrad);
IGNITE_API void* _ignite_adamw (void* params, double lr, double beta1, double beta2, double eps, double weight_decay, bool amsgrad) {
  try {
    return  make_raw::AdamW(ignite_adamw(from_raw::TensorList(params), lr, beta1, beta2, eps, weight_decay, amsgrad));
  } IGNITE_HANDLE_EXCEPTION
  return (void*) NULL;
}
void ignite_adamw_step (optim_adamw opt);
IGNITE_API void _ignite_adamw_step (void* opt) {
  try {
     (ignite_adamw_step(from_raw::AdamW(opt)));
  } IGNITE_HANDLE_EXCEPTION
  
}
void ignite_adamw_zero_grad (optim_adamw opt);
IGNITE_API void _ignite_adamw_zero_grad (void* opt) {
  try {
     (ignite_adamw_zero_grad(from_raw::AdamW(opt)));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim (void* x);
IGNITE_API void _delete_optim (void* x) {
  try {
     (delete_optim(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_sgd (void* x);
IGNITE_API void _delete_optim_sgd (void* x) {
  try {
     (delete_optim_sgd(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_adam (void* x);
IGNITE_API void _delete_optim_adam (void* x) {
  try {
     (delete_optim_adam(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_adamw (void* x);
IGNITE_API void _delete_optim_adamw (void* x) {
  try {
     (delete_optim_adamw(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_adagrad (void* x);
IGNITE_API void _delete_optim_adagrad (void* x) {
  try {
     (delete_optim_adagrad(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_rmsprop (void* x);
IGNITE_API void _delete_optim_rmsprop (void* x) {
  try {
     (delete_optim_rmsprop(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_param_groups (void* x);
IGNITE_API void _delete_optim_param_groups (void* x) {
  try {
     (delete_optim_param_groups(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_optim_param_group (void* x);
IGNITE_API void _delete_optim_param_group (void* x) {
  try {
     (delete_optim_param_group(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_adamw_param_groups (void* x);
IGNITE_API void _delete_adamw_param_groups (void* x) {
  try {
     (delete_adamw_param_groups(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_adamw_param_group (void* x);
IGNITE_API void _delete_adamw_param_group (void* x) {
  try {
     (delete_adamw_param_group(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_adamw_states (void* x);
IGNITE_API void _delete_adamw_states (void* x) {
  try {
     (delete_adamw_states(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
void delete_adamw_state (void* x);
IGNITE_API void _delete_adamw_state (void* x) {
  try {
     (delete_adamw_state(x));
  } IGNITE_HANDLE_EXCEPTION
  
}
